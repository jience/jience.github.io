## 常用命令

- 查看CPU是否支持虚拟化：egrep 'vmx|svm' /proc/cpuinfo

- source ./admin-openrc
- 查看虚机列表：nova list --all
- virsh list



### 查看端口状态

```shell
netstat -anp | grep ESTABLISHED  // 查询所有已建立的TCP连接
netstat -an  // 查看网络端口
netstat -ntlp   // 查看当前所有tcp端口
netstat -ntulp | grep 80  // 查看所有80端口使用情况
netstat -an | grep 3306  // 查看所有3306端口使用情况
netstat -lanp  // 查看服务器上所有端口及服务
netstat -pnt | grep :3306 |wc  // 查看3306端口的连接梳理
netstat -anp | grep 3306  // 查看3306端口的连接客户端IP
ps -ef | grep mysqld  // 查看mysqld服务有几个端口
lsof -i :3306  // 查看所有3306端口的当前连接

netstat -na|wc -l  // 查看服务器的连接数
netstat -nat|grep ESTABLISHED | wc -l  // 查看服务器有效的连接数
netstat -na |awk '/tcp/{print $6}'| sort |uniq -c  //查看服务器不同状态的连接数

cat /proc/19213/net/sockstat  // 判断连接池中的连接有没有正确关闭，如果TCP inuse很大，就可能是连接没有正确关闭

```

### SQL相关

```sql
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'admin123' WITH GRANT OPTION; flush privileges;
```



```shell
show processlist;
show status like '%Aborted_clients%';

# 其他说明
Aborted_clients由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 
Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 
Connections 试图连接MySQL服务器的次数。 
Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。 
Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。 
Delayed_writes 用INSERT DELAYED写入的行数。 
Delayed_errors 用INSERTDELAYED写入的发生某些错误(可能重复键值)的行数。 
Flush_commands 执行FLUSH命令的次数。 
Handler_delete 请求从一张表中删除行的次数。 
Handler_read_first 请求读入表中第一行的次数。 
Handler_read_key 请求数字基于键读行。 
Handler_read_next 请求读入基于一个键的一行的次数。 
Handler_read_rnd 请求读入基于一个固定位置的一行的次数。 
Handler_update 请求更新表中一行的次数。 
Handler_write 请求向表中插入一行的次数。 
Key_blocks_used 用于关键字缓存的块的数量。 
Key_read_requests 请求从缓存读入一个键值的次数。 
Key_reads 从磁盘物理读入一个键值的次数。 
Key_write_requests 请求将一个关键字块写入缓存次数。 
Key_writes 将一个键值块物理写入磁盘的次数。 
Max_used_connections 同时使用的连接的最大数目。 
Not_flushed_key_blocks在键缓存中已经改变但是还没被清空到磁盘上的键块。 
Not_flushed_delayed_rows 在INSERTDELAY队列中等待写入的行的数量。 
Open_tables 打开表的数量。 
Open_files 打开文件的数量。 
Open_streams 打开流的数量(主要用于日志记载） 
Opened_tables 已经打开的表的数量。 
Questions 发往服务器的查询的数量。 
Slow_queries 要花超过long_query_time时间的查询数量。 
Threads_connected 当前打开的连接的数量。 
Threads_running 不在睡眠的线程数量。 
Uptime 服务器工作了多少秒
```

```sql
查询 正在执行的事务：
SELECT * FROM information_schema.INNODB_TRX

查看正在锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 

查看等待锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```

### 分布式锁

要解决APScheduler多实例重复执行任务的问题，最常见的解决方案就是使用分布式锁，而分布式锁中最常见的就是基于Redis构建的字段锁。

Redis字段锁很容易理解，就是通过set命令在redis中设置一个字段，如果字段存在，则是加锁状态，而字段不存在，则是解锁状态。

设计Redis锁时，需要考虑操作原子性，避免同时去获取Redis字段的情况出现，还需要考虑字段超时，避免因逻辑错误出现的长时间死锁，所以设计Redis字段锁还是需要一些tick的，这里分享一种写法。



### QEMU

```shell
qemu-img convert -O qcow2 原文件名 新文件名
qemu-img convert -O qcow2 volume-839f3f2d-6056-4d34-9c91-29b6b4a29e81 VDI_MANAGER_14.qcow2   增量转全量
qemu-img convert -c -O qcow2 VDI_MANAGER_14.qcow2 VDI_MANAGER_14_compre.qcow2  压缩

```

#### 系统IO性能监测

```shell
# 对系统的磁盘操作活动进行监视
iostat -d -x -k 1 1

# 查看磁盘读写
vmstat -d 1 1

# 查看磁盘历史IO信息
sar -d 1 1
```

#### 测试磁盘写能力

````shell
dd if=/dev/zero of=/path/to/file count=2048k conv=fsync

从一个文件写入另一文件，返回耗时和速度。
因为/dev/zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。
conv=fsync 加入这个参数后，dd命令执行到最后会真正执行一次“同步(sync)”操作，这样算出来的时间才是比较符合实际使用结果的。（如果没有这个参数，只是写缓存，速度快很多）。
````

#### 测试磁盘读能力

```shell
dd if=/dev/sda of=/dev/null bs=4k

/dev/sda是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sda上，也相当于测试磁盘的读能力。
```



### MYSQL

```sql
// 新建用户admin,密码123456,只能从本地登录mysql所在服务器
CREATE USER 'admin'@'localhost' IDENTIFIED BY '123456';
// 新建用户admin,密码123456,可以从其他任意地址远程登录mysql所在服务器
CREATE USER 'admin'@'%' IDENTIFIED BY '123456';
// 新建用户admin,没有密码,可以从其他任意地址远程登录mysql所在服务器
CREATE USER 'admin'@'%';

// 删除用户
DROP USER 'username'@'host';

// 给用户admin授权所有库所有表的所有权限，并授权用户能给其他用户授权
GRANT ALL ON *.* TO 'admin'@'localhost' WITH GRANT OPTION;
// 回收权限
REVOKE priviliges ON database.tablename FROM 'username'@'host';
// 立即生效
FLUSH PRIVILIGES;
```

